// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/we7coreteam/gorm-gen-yaml/output/entity"
)

func newDeclarationLog(db *gorm.DB, opts ...gen.DOOption) declarationLog {
	_declarationLog := declarationLog{}

	_declarationLog.declarationLogDo.UseDB(db, opts...)
	_declarationLog.declarationLogDo.UseModel(&entity.DeclarationLog{})

	tableName := _declarationLog.declarationLogDo.TableName()
	_declarationLog.ALL = field.NewAsterisk(tableName)
	_declarationLog.ID = field.NewInt32(tableName, "id")
	_declarationLog.UserID = field.NewInt32(tableName, "user_id")
	_declarationLog.ClubID = field.NewInt32(tableName, "club_id")
	_declarationLog.DeclarationGiftID = field.NewInt32(tableName, "declaration_gift_id")
	_declarationLog.DeclarationProjectID = field.NewInt32(tableName, "declaration_project_id")
	_declarationLog.AcceptUserID = field.NewInt32(tableName, "accept_user_id")
	_declarationLog.OwnerID = field.NewInt32(tableName, "owner_id")
	_declarationLog.AcceptUserName = field.NewString(tableName, "accept_user_name")
	_declarationLog.OwnerName = field.NewString(tableName, "owner_name")
	_declarationLog.OwnerManageUserName = field.NewString(tableName, "owner_manage_user_name")
	_declarationLog.Price = field.NewFloat64(tableName, "price")
	_declarationLog.Nums = field.NewInt32(tableName, "nums")
	_declarationLog.NumsOld = field.NewInt32(tableName, "nums_old")
	_declarationLog.BossName = field.NewString(tableName, "boss_name")
	_declarationLog.BossUserID = field.NewInt32(tableName, "boss_user_id")
	_declarationLog.DeclarationGiftName = field.NewString(tableName, "declaration_gift_name")
	_declarationLog.Amount = field.NewFloat64(tableName, "amount")
	_declarationLog.Commission = field.NewFloat64(tableName, "commission")
	_declarationLog.Rebate = field.NewFloat64(tableName, "rebate")
	_declarationLog.DeclarationType = field.NewInt32(tableName, "declaration_type")
	_declarationLog.Status = field.NewString(tableName, "status")
	_declarationLog.ApproveMemo = field.NewString(tableName, "approve_memo")
	_declarationLog.Memo = field.NewString(tableName, "memo")
	_declarationLog.AcceptTime = field.NewInt32(tableName, "accept_time")
	_declarationLog.AcceptEndTime = field.NewInt32(tableName, "accept_end_time")
	_declarationLog.CreateTime = field.NewInt32(tableName, "create_time")
	_declarationLog.UpdateTime = field.NewInt32(tableName, "update_time")
	_declarationLog.DeleteTime = field.NewInt32(tableName, "delete_time")
	_declarationLog.Club = declarationLogHasOneClub{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Club", "entity.Club"),
		ClubUser: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Club.ClubUser", "entity.ClubUser"),
		},
		User: struct {
			field.RelationField
			UserOauth struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Club.User", "entity.User"),
			UserOauth: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Club.User.UserOauth", "entity.UserOauth"),
			},
		},
	}

	_declarationLog.DeclarationGift = declarationLogHasOneDeclarationGift{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("DeclarationGift", "entity.DeclarationGift"),
	}

	_declarationLog.fillFieldMap()

	return _declarationLog
}

type declarationLog struct {
	declarationLogDo

	ALL                  field.Asterisk
	ID                   field.Int32
	UserID               field.Int32   // 提交用户ID
	ClubID               field.Int32   // 俱乐部ID
	DeclarationGiftID    field.Int32   // 礼物单ID
	DeclarationProjectID field.Int32   // 项目清单ID
	AcceptUserID         field.Int32   // 接单人ID
	OwnerID              field.Int32   // 所属人ID
	AcceptUserName       field.String  // 接单人名称
	OwnerName            field.String  // 所属陪名称
	OwnerManageUserName  field.String  // 审批管理员名称
	Price                field.Float64 // 单价
	Nums                 field.Int32   // 单量
	NumsOld              field.Int32   // 未折算前的单量
	BossName             field.String  // 老板名称
	BossUserID           field.Int32   // 老板uid
	DeclarationGiftName  field.String  // 礼物名称
	Amount               field.Float64 // 总金额
	Commission           field.Float64 // 抽成
	Rebate               field.Float64 // 返利
	DeclarationType      field.Int32   // 报单类型:0=游戏单,1=礼物单
	Status               field.String  // 状态:0=待审批,1=已审批,2=已驳回
	ApproveMemo          field.String  // 审批备注
	Memo                 field.String  // 备注
	AcceptTime           field.Int32   // 接单时间
	AcceptEndTime        field.Int32   // 接单结束时间
	CreateTime           field.Int32   // 添加时间
	UpdateTime           field.Int32   // 修改时间
	DeleteTime           field.Int32   // 删除时间
	Club                 declarationLogHasOneClub

	DeclarationGift declarationLogHasOneDeclarationGift

	fieldMap map[string]field.Expr
}

func (d declarationLog) Table(newTableName string) *declarationLog {
	d.declarationLogDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d declarationLog) As(alias string) *declarationLog {
	d.declarationLogDo.DO = *(d.declarationLogDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *declarationLog) updateTableName(table string) *declarationLog {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt32(table, "id")
	d.UserID = field.NewInt32(table, "user_id")
	d.ClubID = field.NewInt32(table, "club_id")
	d.DeclarationGiftID = field.NewInt32(table, "declaration_gift_id")
	d.DeclarationProjectID = field.NewInt32(table, "declaration_project_id")
	d.AcceptUserID = field.NewInt32(table, "accept_user_id")
	d.OwnerID = field.NewInt32(table, "owner_id")
	d.AcceptUserName = field.NewString(table, "accept_user_name")
	d.OwnerName = field.NewString(table, "owner_name")
	d.OwnerManageUserName = field.NewString(table, "owner_manage_user_name")
	d.Price = field.NewFloat64(table, "price")
	d.Nums = field.NewInt32(table, "nums")
	d.NumsOld = field.NewInt32(table, "nums_old")
	d.BossName = field.NewString(table, "boss_name")
	d.BossUserID = field.NewInt32(table, "boss_user_id")
	d.DeclarationGiftName = field.NewString(table, "declaration_gift_name")
	d.Amount = field.NewFloat64(table, "amount")
	d.Commission = field.NewFloat64(table, "commission")
	d.Rebate = field.NewFloat64(table, "rebate")
	d.DeclarationType = field.NewInt32(table, "declaration_type")
	d.Status = field.NewString(table, "status")
	d.ApproveMemo = field.NewString(table, "approve_memo")
	d.Memo = field.NewString(table, "memo")
	d.AcceptTime = field.NewInt32(table, "accept_time")
	d.AcceptEndTime = field.NewInt32(table, "accept_end_time")
	d.CreateTime = field.NewInt32(table, "create_time")
	d.UpdateTime = field.NewInt32(table, "update_time")
	d.DeleteTime = field.NewInt32(table, "delete_time")

	d.fillFieldMap()

	return d
}

func (d *declarationLog) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *declarationLog) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 30)
	d.fieldMap["id"] = d.ID
	d.fieldMap["user_id"] = d.UserID
	d.fieldMap["club_id"] = d.ClubID
	d.fieldMap["declaration_gift_id"] = d.DeclarationGiftID
	d.fieldMap["declaration_project_id"] = d.DeclarationProjectID
	d.fieldMap["accept_user_id"] = d.AcceptUserID
	d.fieldMap["owner_id"] = d.OwnerID
	d.fieldMap["accept_user_name"] = d.AcceptUserName
	d.fieldMap["owner_name"] = d.OwnerName
	d.fieldMap["owner_manage_user_name"] = d.OwnerManageUserName
	d.fieldMap["price"] = d.Price
	d.fieldMap["nums"] = d.Nums
	d.fieldMap["nums_old"] = d.NumsOld
	d.fieldMap["boss_name"] = d.BossName
	d.fieldMap["boss_user_id"] = d.BossUserID
	d.fieldMap["declaration_gift_name"] = d.DeclarationGiftName
	d.fieldMap["amount"] = d.Amount
	d.fieldMap["commission"] = d.Commission
	d.fieldMap["rebate"] = d.Rebate
	d.fieldMap["declaration_type"] = d.DeclarationType
	d.fieldMap["status"] = d.Status
	d.fieldMap["approve_memo"] = d.ApproveMemo
	d.fieldMap["memo"] = d.Memo
	d.fieldMap["accept_time"] = d.AcceptTime
	d.fieldMap["accept_end_time"] = d.AcceptEndTime
	d.fieldMap["create_time"] = d.CreateTime
	d.fieldMap["update_time"] = d.UpdateTime
	d.fieldMap["delete_time"] = d.DeleteTime

}

func (d declarationLog) clone(db *gorm.DB) declarationLog {
	d.declarationLogDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d declarationLog) replaceDB(db *gorm.DB) declarationLog {
	d.declarationLogDo.ReplaceDB(db)
	return d
}

type declarationLogHasOneClub struct {
	db *gorm.DB

	field.RelationField

	ClubUser struct {
		field.RelationField
	}
	User struct {
		field.RelationField
		UserOauth struct {
			field.RelationField
		}
	}
}

func (a declarationLogHasOneClub) Where(conds ...field.Expr) *declarationLogHasOneClub {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a declarationLogHasOneClub) WithContext(ctx context.Context) *declarationLogHasOneClub {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a declarationLogHasOneClub) Session(session *gorm.Session) *declarationLogHasOneClub {
	a.db = a.db.Session(session)
	return &a
}

func (a declarationLogHasOneClub) Model(m *entity.DeclarationLog) *declarationLogHasOneClubTx {
	return &declarationLogHasOneClubTx{a.db.Model(m).Association(a.Name())}
}

type declarationLogHasOneClubTx struct{ tx *gorm.Association }

func (a declarationLogHasOneClubTx) Find() (result *entity.Club, err error) {
	return result, a.tx.Find(&result)
}

func (a declarationLogHasOneClubTx) Append(values ...*entity.Club) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a declarationLogHasOneClubTx) Replace(values ...*entity.Club) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a declarationLogHasOneClubTx) Delete(values ...*entity.Club) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a declarationLogHasOneClubTx) Clear() error {
	return a.tx.Clear()
}

func (a declarationLogHasOneClubTx) Count() int64 {
	return a.tx.Count()
}

type declarationLogHasOneDeclarationGift struct {
	db *gorm.DB

	field.RelationField
}

func (a declarationLogHasOneDeclarationGift) Where(conds ...field.Expr) *declarationLogHasOneDeclarationGift {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a declarationLogHasOneDeclarationGift) WithContext(ctx context.Context) *declarationLogHasOneDeclarationGift {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a declarationLogHasOneDeclarationGift) Session(session *gorm.Session) *declarationLogHasOneDeclarationGift {
	a.db = a.db.Session(session)
	return &a
}

func (a declarationLogHasOneDeclarationGift) Model(m *entity.DeclarationLog) *declarationLogHasOneDeclarationGiftTx {
	return &declarationLogHasOneDeclarationGiftTx{a.db.Model(m).Association(a.Name())}
}

type declarationLogHasOneDeclarationGiftTx struct{ tx *gorm.Association }

func (a declarationLogHasOneDeclarationGiftTx) Find() (result *entity.DeclarationGift, err error) {
	return result, a.tx.Find(&result)
}

func (a declarationLogHasOneDeclarationGiftTx) Append(values ...*entity.DeclarationGift) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a declarationLogHasOneDeclarationGiftTx) Replace(values ...*entity.DeclarationGift) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a declarationLogHasOneDeclarationGiftTx) Delete(values ...*entity.DeclarationGift) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a declarationLogHasOneDeclarationGiftTx) Clear() error {
	return a.tx.Clear()
}

func (a declarationLogHasOneDeclarationGiftTx) Count() int64 {
	return a.tx.Count()
}

type declarationLogDo struct{ gen.DO }

type IDeclarationLogDo interface {
	gen.SubQuery
	Debug() IDeclarationLogDo
	WithContext(ctx context.Context) IDeclarationLogDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDeclarationLogDo
	WriteDB() IDeclarationLogDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDeclarationLogDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDeclarationLogDo
	Not(conds ...gen.Condition) IDeclarationLogDo
	Or(conds ...gen.Condition) IDeclarationLogDo
	Select(conds ...field.Expr) IDeclarationLogDo
	Where(conds ...gen.Condition) IDeclarationLogDo
	Order(conds ...field.Expr) IDeclarationLogDo
	Distinct(cols ...field.Expr) IDeclarationLogDo
	Omit(cols ...field.Expr) IDeclarationLogDo
	Join(table schema.Tabler, on ...field.Expr) IDeclarationLogDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDeclarationLogDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDeclarationLogDo
	Group(cols ...field.Expr) IDeclarationLogDo
	Having(conds ...gen.Condition) IDeclarationLogDo
	Limit(limit int) IDeclarationLogDo
	Offset(offset int) IDeclarationLogDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDeclarationLogDo
	Unscoped() IDeclarationLogDo
	Create(values ...*entity.DeclarationLog) error
	CreateInBatches(values []*entity.DeclarationLog, batchSize int) error
	Save(values ...*entity.DeclarationLog) error
	First() (*entity.DeclarationLog, error)
	Take() (*entity.DeclarationLog, error)
	Last() (*entity.DeclarationLog, error)
	Find() ([]*entity.DeclarationLog, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.DeclarationLog, err error)
	FindInBatches(result *[]*entity.DeclarationLog, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*entity.DeclarationLog) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDeclarationLogDo
	Assign(attrs ...field.AssignExpr) IDeclarationLogDo
	Joins(fields ...field.RelationField) IDeclarationLogDo
	Preload(fields ...field.RelationField) IDeclarationLogDo
	FirstOrInit() (*entity.DeclarationLog, error)
	FirstOrCreate() (*entity.DeclarationLog, error)
	FindByPage(offset int, limit int) (result []*entity.DeclarationLog, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDeclarationLogDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d declarationLogDo) Debug() IDeclarationLogDo {
	return d.withDO(d.DO.Debug())
}

func (d declarationLogDo) WithContext(ctx context.Context) IDeclarationLogDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d declarationLogDo) ReadDB() IDeclarationLogDo {
	return d.Clauses(dbresolver.Read)
}

func (d declarationLogDo) WriteDB() IDeclarationLogDo {
	return d.Clauses(dbresolver.Write)
}

func (d declarationLogDo) Session(config *gorm.Session) IDeclarationLogDo {
	return d.withDO(d.DO.Session(config))
}

func (d declarationLogDo) Clauses(conds ...clause.Expression) IDeclarationLogDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d declarationLogDo) Returning(value interface{}, columns ...string) IDeclarationLogDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d declarationLogDo) Not(conds ...gen.Condition) IDeclarationLogDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d declarationLogDo) Or(conds ...gen.Condition) IDeclarationLogDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d declarationLogDo) Select(conds ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d declarationLogDo) Where(conds ...gen.Condition) IDeclarationLogDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d declarationLogDo) Order(conds ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d declarationLogDo) Distinct(cols ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d declarationLogDo) Omit(cols ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d declarationLogDo) Join(table schema.Tabler, on ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d declarationLogDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d declarationLogDo) RightJoin(table schema.Tabler, on ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d declarationLogDo) Group(cols ...field.Expr) IDeclarationLogDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d declarationLogDo) Having(conds ...gen.Condition) IDeclarationLogDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d declarationLogDo) Limit(limit int) IDeclarationLogDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d declarationLogDo) Offset(offset int) IDeclarationLogDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d declarationLogDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDeclarationLogDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d declarationLogDo) Unscoped() IDeclarationLogDo {
	return d.withDO(d.DO.Unscoped())
}

func (d declarationLogDo) Create(values ...*entity.DeclarationLog) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d declarationLogDo) CreateInBatches(values []*entity.DeclarationLog, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d declarationLogDo) Save(values ...*entity.DeclarationLog) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d declarationLogDo) First() (*entity.DeclarationLog, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*entity.DeclarationLog), nil
	}
}

func (d declarationLogDo) Take() (*entity.DeclarationLog, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*entity.DeclarationLog), nil
	}
}

func (d declarationLogDo) Last() (*entity.DeclarationLog, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*entity.DeclarationLog), nil
	}
}

func (d declarationLogDo) Find() ([]*entity.DeclarationLog, error) {
	result, err := d.DO.Find()
	return result.([]*entity.DeclarationLog), err
}

func (d declarationLogDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*entity.DeclarationLog, err error) {
	buf := make([]*entity.DeclarationLog, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d declarationLogDo) FindInBatches(result *[]*entity.DeclarationLog, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d declarationLogDo) Attrs(attrs ...field.AssignExpr) IDeclarationLogDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d declarationLogDo) Assign(attrs ...field.AssignExpr) IDeclarationLogDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d declarationLogDo) Joins(fields ...field.RelationField) IDeclarationLogDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d declarationLogDo) Preload(fields ...field.RelationField) IDeclarationLogDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d declarationLogDo) FirstOrInit() (*entity.DeclarationLog, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*entity.DeclarationLog), nil
	}
}

func (d declarationLogDo) FirstOrCreate() (*entity.DeclarationLog, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*entity.DeclarationLog), nil
	}
}

func (d declarationLogDo) FindByPage(offset int, limit int) (result []*entity.DeclarationLog, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d declarationLogDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d declarationLogDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d declarationLogDo) Delete(models ...*entity.DeclarationLog) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *declarationLogDo) withDO(do gen.Dao) *declarationLogDo {
	d.DO = *do.(*gen.DO)
	return d
}
